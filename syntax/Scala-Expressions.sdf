module Scala-Expressions

imports
	Scala-Whitespace
	Scala-Literals
	Scala-Paths
	Scala-Types
	Scala-Annotations
	Scala-PatternMatching
	Scala-Modifiers
	Scala-Imports
	Scala-Templates
	
exports
	lexical syntax
		";" -> Semi
		"\n" -> Nl
		"+" -> Prefix
		"-" -> Prefix
		"~" -> Prefix
		"!" -> Prefix
		
	lexical restrictions
		Prefix -/- [\+\-\~\!]


	%% With Layout
	context-free priorities
		{
			"_"                    -> Expr {"WildcardExpr"}
			Literal                -> Expr {"LiteralExpr", prefer}
			Path                   -> Expr {"PathExpr"}
			Expr ArgumentExprs     -> Expr {"AppExpr", layout("1.last.line == 2.first.line")}
			Expr BlockExpr         -> Expr {"BlockAppExpr", layout("2.first.line - 1.last.line < num(2)")}
			"(" {NoLExpr ","}* ")" -> Expr {"TupleExpr"}
			Expr TypeArgs          -> Expr {"TypeApplication"}
		}

		> {
			"new" ClassTemplate -> Expr {"NewClassExpr", prefer}
			"new" TemplateBody  -> Expr {"NewTemplateExpr", prefer}
			BlockExpr           -> Expr
			Expr "_"            -> Expr {"EtaExpansionExpr", left, layout("1.last.line == 2.first.line")}
		}
			
		> Prefix Expr  -> Expr {"PrefixExpr", right, prefer}
		> Expr Id Expr -> Expr {"InfixExpr", left, avoid, layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
		> Expr Id      -> Expr {"PostfixExpr", layout("1.last.line == 2.first.line")}
		> Expr Id      -> Expr {"PostfixExpr", layout("1.last.line == 2.first.line")}

		> {
			Bindings "=>" Expr                                                   -> Expr {"FunExpr", prefer}
			Id "=>" Expr                                                         -> Expr {"IdFunExpr", prefer}
			"implicit" Id "=>" Expr                                              -> Expr {"ImplicitFunExpr", prefer}
			"_" "=>" Expr                                                        -> Expr {"WildcardFunExpr", prefer}
			"if" "(" NoLExpr ")" Expr                                            -> Expr {"IfExpr"}
			"if" "(" NoLExpr ")" Expr "else" Expr                                -> Expr {"IfElseExpr"}
			"if" "(" NoLExpr ")" Expr ";" "else" Expr                            -> Expr {"IfElseExpr"}
			"while" "(" NoLExpr ")" Expr                                         -> Expr {"WhileExpr"}
			"try" "{" Block "}" ("catch" "{" CaseClauses "}")? ("finally" Expr)? -> Expr {"TryExpr"}
			"do" Expr Semi? "while" "(" Expr ")"                                 -> Expr {"DoWhileExpr"}
			"for" "(" Enumerators ")" Expr                                       -> Expr {"BraceForExpr"}
			"for" "{" Enumerators "}" Expr                                       -> Expr {"CurlyBraceForExpr"}
			"for" "(" Enumerators ")" "yield" Expr                               -> Expr {"BraceYieldForExpr"}
			"for" "{" Enumerators "}" "yield" Expr                               -> Expr {"CurlyBraceYieldForExpr"}
			"throw" Expr                                                         -> Expr {"ThrowExpr"}
			"return" Expr?                                                       -> Expr {"ReturnExpr"}
			Expr Ascription                                                      -> Expr {"AscriptionExpr", avoid}
			Expr "match" "{" CaseClauses "}"                                     -> Expr {"MatchExpr"}
			(Expr ".")? Id "=" Expr                                              -> Expr {"AssignmentExpr", non-assoc}
			Expr ArgumentExprs "=" Expr                                          -> Expr {"AccessAssignmentExpr", non-assoc}
		}

	context-free priorities
		Expr "." Id        -> Expr {"DesignatorExpr", avoid}
		> Prefix Expr      -> Expr {"PrefixExpr"}


	%% Without Layout
	context-free priorities
		{
			"_"                    -> NoLExpr {"WildcardNoLExpr"}
			Literal                -> NoLExpr {"LiteralNoLExpr", prefer}
			Path                   -> NoLExpr {"PathNoLExpr"}
			NoLExpr ArgumentExprs  -> NoLExpr {"AppNoLExpr"}
			NoLExpr BlockExpr      -> NoLExpr {"BlockAppNoLExpr"}
			"(" {NoLExpr ","}* ")" -> NoLExpr {"TupleNoLExpr"}
			NoLExpr TypeArgs       -> NoLExpr {"TypeApplication"}
		}

		> {
			"new" ClassTemplate -> NoLExpr {"NewClassNoLExpr", prefer}
			"new" TemplateBody  -> NoLExpr {"NewTemplateNoLExpr", prefer}
			BlockExpr           -> NoLExpr
			NoLExpr "_"         -> NoLExpr {"EtaExpansionNoLExpr", left}
		}

		> Prefix NoLExpr     -> NoLExpr {"PrefixNoLExpr", right, prefer}
		> NoLExpr Id NoLExpr -> NoLExpr {"InfixNoLExpr", left, avoid}
		> NoLExpr Id         -> NoLExpr {"PostfixNoLExpr"}
		> NoLExpr Id         -> NoLExpr {"PostfixNoLExpr"}

		> {
			Bindings "=>" NoLExpr                                                   -> NoLExpr {"FunNoLExpr", prefer}
			Id "=>" NoLExpr                                                         -> NoLExpr {"IdFunNoLExpr", prefer}
			"implicit" Id "=>" NoLExpr                                              -> NoLExpr {"ImplicitFunNoLExpr", prefer}
			"_" "=>" NoLExpr                                                        -> NoLExpr {"WildcardFunNoLExpr", prefer}
			"if" "(" NoLExpr ")" NoLExpr                                            -> NoLExpr {"IfNoLExpr"}
			"if" "(" NoLExpr ")" NoLExpr "else" NoLExpr                             -> NoLExpr {"IfElseNoLExpr"}
			"if" "(" NoLExpr ")" NoLExpr ";" "else" NoLExpr                         -> NoLExpr {"IfElseNoLExpr"}
			"while" "(" NoLExpr ")" NoLExpr                                         -> NoLExpr {"WhileNoLExpr"}
			"try" "{" Block "}" ("catch" "{" CaseClauses "}")? ("finally" NoLExpr)? -> NoLExpr {"TryNoLExpr"}
			"do" NoLExpr Semi? "while" "(" NoLExpr ")"                              -> NoLExpr {"DoWhileNoLExpr"}
			"for" "(" Enumerators ")" NoLExpr                                       -> NoLExpr {"BraceForNoLExpr"}
			"for" "{" Enumerators "}" NoLExpr                                       -> NoLExpr {"CurlyBraceForNoLExpr"}
			"for" "(" Enumerators ")" "yield" NoLExpr                               -> NoLExpr {"BraceYieldForNoLExpr"}
			"for" "{" Enumerators "}" "yield" NoLExpr                               -> NoLExpr {"CurlyBraceYieldForNoLExpr"}
			"throw" NoLExpr                                                         -> NoLExpr {"ThrowNoLExpr"}
			"return" NoLExpr?                                                       -> NoLExpr {"ReturnNoLExpr"}
			NoLExpr Ascription                                                      -> NoLExpr {"AscriptionNoLExpr", avoid}
			NoLExpr "match" "{" CaseClauses "}"                                     -> NoLExpr {"MatchNoLExpr"}
			(NoLExpr ".")? Id "=" NoLExpr                                           -> NoLExpr {"AssignmentNoLExpr", non-assoc}
			NoLExpr ArgumentExprs "=" NoLExpr                                       -> NoLExpr {"AccessAssignmentNoLExpr", non-assoc}
		}

	context-free priorities
		NoLExpr "." Id        -> NoLExpr {"DesignatorNoLExpr", avoid}
		> Prefix NoLExpr      -> NoLExpr {"PrefixNoLExpr"}



	context-free syntax
		"(" NoLExprs? ")"                               -> ArgumentExprs {"ArgumentExprs"}
		"(" (NoLExprs ",")? NoLExpr ":" "_" "*" ")"     -> ArgumentExprs {"SequenceArgumentExprs", prefer}

		ArgumentExprs                  -> ArgumentExprsSeq
		ArgumentExprs ArgumentExprsSeq -> ArgumentExprsSeq {"ArgumentExprsSeq", layout("1.last.line == 2.first.line")}

		{NoLExpr ","}+ -> NoLExprs {"Exprs"}
		
		":" InfixType   -> Ascription {"TypeAscription"}
		":" Annotation+ -> Ascription {"AnnotationAscription"}
		":" "_" "*"     -> Ascription {"SequenceAscription"}
		
		Pattern1 "<-" Expr Guard? -> Generator {"Generator"}
		
		"if" Expr -> Guard {"Guard"}
		
		Generator                   -> Enumerators 
		Generator ";" EnumeratorSeq -> Enumerators {"SemiEnumerators"}
		Generator EnumeratorSeq     -> Enumerators {"Enumerators", layout("2.first.line > 1.last.line")}
		
		Enumerator                   -> EnumeratorSeq {"SingleEnumeratorSeq"}
		Enumerator ";" EnumeratorSeq -> EnumeratorSeq {"SemiEnumeratorSeq"}
		Enumerator EnumeratorSeq     -> EnumeratorSeq {"EnumeratorSeq", layout("2.first.line > 1.last.line")}
		
		Generator                    -> Enumerator
		Guard                        -> Enumerator
		"val" Pattern1 "=" Expr -> Enumerator {"Enumerator"}
		
		"case" Pattern Guard? "=>" Block -> CaseClause {"CaseClause"}
		
		CaseClause+ -> CaseClauses {"CaseClauses"}
		
		"{" CaseClauses "}" -> BlockExpr {"CaseBlockExpr"}
		"{" Block "}"       -> BlockExpr {"BlockExpr"}
		
		BlockStatSemi* ResultExpr -> Block {"BlockWithResult", prefer}
		BlockStatSemi*            -> Block {"BlockWithoutResult"}
		
		BlockStat EOL -> BlockStatSemi {"BlockStatSemi", enforce-newline, prefer}
		BlockStat EOB -> BlockStatSemi {"EOBBlockStatSemi", avoid}
		BlockStat ";" -> BlockStatSemi {"SemiBlockStatSemi"}
		
		%% Only treat "special" expressions as ResultExpr to avoid ambiguity with BlockStatSemi
		%% Expr1                                     -> ResultExpr
		Bindings "=>" Block                       -> ResultExpr {"BindingsResultExpr"}
		"implicit" Id ":" CompoundType "=>" Block -> ResultExpr {"ImplicitResultExpr"}
		Id ":" CompoundType "=>" Block            -> ResultExpr {"SimpleResultExpr"}
		"_" ":" CompoundType "=>" Block           -> ResultExpr {"WildcardResultExpr"}
		Id "=>" Block                             -> ResultExpr {"SpecialOneArgResultExpr"}
		
		Import                             -> BlockStat
		Expr                               -> BlockStat
		Annotation* LocalModifier* TmplDef -> BlockStat {"TmplDefBlockStat", prefer}
		Annotation* Def                    -> BlockStat {"DefBlockStat"}
		Annotation* "implicit" Def         -> BlockStat {"ImplicitDefBlockStat"}
		Annotation* "lazy" Def             -> BlockStat {"LazyDefBlockStat"}

			
		Id (":" Type)?  -> Binding {"Binding"}
		"_" (":" Type)? -> Binding {"WildCardBinding"}
		
		"(" {Binding ","}* ")" -> Bindings {"Bindings"}

		"=" Expr -> Assignment {"Assignment"}

module Scala-Expressions

imports
	Scala-Whitespace
	Scala-Literals
	Scala-Paths
	Scala-Types
	Scala-Annotations
	Scala-PatternMatching
	Scala-Modifiers
	Scala-Imports
	Scala-Templates
	
exports
	lexical syntax
		";" -> Semi
		"\n" -> Nl
		"+" -> Prefix
		"-" -> Prefix
		"~" -> Prefix
		"!" -> Prefix
		"=" -> AssignOp
	
	lexical restrictions
		AssignOp -/- [\>]
	
	context-free syntax
		Expr1                   -> Expr {avoid}
		FunExpr                 -> Expr {prefer}
		
		Bindings "=>" Expr      -> FunExpr {"FunExpr"}
		Id "=>" Expr            -> FunExpr {"IdFunExpr"}
		"implicit" Id "=>" Expr -> FunExpr {"ImplicitFunExpr"}
		"_" "=>" Expr           -> FunExpr {"WildcardFunExpr"}
		
		"if" "(" Expr ")" Expr                                               -> Expr1 {"IfExpr"}
		"if" "(" Expr ")" Expr "else" Expr                                   -> Expr1 {"IfElseExpr"}
		"if" "(" Expr ")" Expr ";" "else" Expr                               -> Expr1 {"IfElseExpr"}
		"while" "(" Expr ")" Expr                                            -> Expr1 {"WhileExpr"}
		"try" "{" Block "}" ("catch" "{" CaseClauses "}")? ("finally" Expr)? -> Expr1 {"TryExpr"}
		"do" Expr Semi? "while" "(" Expr ")"                                 -> Expr1 {"DoWhileExpr"}
		"for" "(" Enumerators ")" Expr                                       -> Expr1 {"BraceForExpr"}
		"for" "{" Enumerators "}" Expr                                       -> Expr1 {"CurlyBraceForExpr"}
		"for" "(" Enumerators ")" "yield" Expr                               -> Expr1 {"BraceYieldForExpr"}
		"for" "{" Enumerators "}" "yield" Expr                               -> Expr1 {"CurlyBraceYieldForExpr"}
		"throw" Expr                                                         -> Expr1 {"ThrowExpr"}
		"return" Expr                                                        -> Expr1 {"ReturnExpr"}
		(SimpleExpr ".")? Id AssignOp Expr                                   -> Expr1 {"AssignmentExpr"}
		SimpleExpr1 ArgumentExprs AssignOp Expr                              -> Expr1 {"AccessAssignmentExpr"}
		PostfixExpr                                                          -> Expr1
		PostfixExpr Ascription                                               -> Expr1 {"AscriptionExpr"}
		PostfixExpr "match" "{" CaseClauses "}"                              -> Expr1 {"MatchExpr"}
		
		%% TODO: Inline this to express the optional newline, disables "real" PostfixExprs until then
		%%InfixExpr (Id Nl?)? -> PostfixExpr {"PostfixExpr"}
		InfixExpr    -> PostfixExpr
		InfixExpr Id -> PostfixExpr {"PostfixExpr"}

		PrefixExpr             -> InfixExpr
		InfixExpr Id InfixExpr -> InfixExpr {"InfixExpr", layout("3.first.line - 2.last.line < num(2)")}
		
		Prefix SimpleExpr -> PrefixExpr{"PrefixExpr"}
		SimpleExpr        -> PrefixExpr
		
		"new" ClassTemplate -> SimpleExpr {"NewClassExpr"}
		"new" TemplateBody  -> SimpleExpr {"NewTemplateExpr"}
		BlockExpr           -> SimpleExpr
		SimpleExpr1         -> SimpleExpr
		SimpleExpr1 "_"     -> SimpleExpr {"ToFunctionEtaExpansion"}
			
		Literal                   -> SimpleExpr1
		Path                      -> SimpleExpr1 {avoid}
		"_"                       -> SimpleExpr1 {"WildcardExpr"}
		"(" Exprs? ")"            -> SimpleExpr1 {"TupleExpr"}
		SimpleExpr "." Id         -> SimpleExpr1 {"DesignatorExpr", prefer}
		SimpleExpr TypeArgs       -> SimpleExpr1 {"TypeApplication"}
		SimpleExpr1 ArgumentExprs -> SimpleExpr1 {"AppExpr"}
			
		"(" Exprs? ")"                               -> ArgumentExprs {"ArgumentExprs"}
		"(" (Exprs ",")? PostfixExpr ":" "_" "*" ")" -> ArgumentExprs {"SequenceArgumentExprs", prefer}
		%% TODO: Need to inline this because of optional nl in the beginning
		Nl? BlockExpr                                -> ArgumentExprs {"BlockArgumentExprs"}
		
		{Expr ","}+ -> Exprs {"Exprs"}
		
		":" InfixType   -> Ascription {"TypeAscription"}
		":" Annotation+ -> Ascription {"AnnotationAscription"}
		":" "_" "*"     -> Ascription {"SequenceAscription"}
		
		Pattern1 "<-" Expr Guard? -> Generator {"Generator"}
		
		"if" PostfixExpr -> Guard {"Guard"}
		
		Generator                   -> Enumerators 
		Generator ";" EnumeratorSeq -> Enumerators {"SemiEnumerators"}
		Generator EnumeratorSeq     -> Enumerators {"Enumerators", layout("2.first.line > 1.last.line")}
		
		Enumerator                   -> EnumeratorSeq {"SingleEnumeratorSeq"}
		Enumerator ";" EnumeratorSeq -> EnumeratorSeq {"SemiEnumeratorSeq"}
		Enumerator EnumeratorSeq     -> EnumeratorSeq {"EnumeratorSeq", layout("2.first.line > 1.last.line")}
		
		Generator               -> Enumerator
		Guard                   -> Enumerator
		"val" Pattern1 "=" Expr -> Enumerator {"Enumerator"}
		
		"case" Pattern Guard? "=>" Block -> CaseClause {"CaseClause"}
		
		CaseClause+ -> CaseClauses {"CaseClauses"}
		
		"{" CaseClauses "}" -> BlockExpr {"CaseBlockExpr"}
		"{" Block "}"       -> BlockExpr {"BlockExpr"}
		
		BlockStatSemi* ResultExpr -> Block {"BlockWithResult", prefer}
		BlockStatSemi*            -> Block {"BlockWithoutResult"}
		
		BlockStat EOL -> BlockStatSemi {"BlockStatSemi", enforce-newline, prefer}
		BlockStat EOB -> BlockStatSemi {"EOBBlockStatSemi", avoid}
		BlockStat ";" -> BlockStatSemi {"SemiBlockStatSemi"}
		
		%% Only treat "special" expressions as ResultExpr to avoid ambiguity with BlockStatSemi
		%% Expr1                                     -> ResultExpr
		Bindings "=>" Block                       -> ResultExpr {"BindingsResultExpr"}
		"implicit" Id ":" CompoundType "=>" Block -> ResultExpr {"ImplicitResultExpr"}
		Id ":" CompoundType "=>" Block            -> ResultExpr {"SimpleResultExpr"}
		"_" ":" CompoundType "=>" Block           -> ResultExpr {"WildcardResultExpr"}
		
		Import                             -> BlockStat
		Expr1                              -> BlockStat
		Annotation* Def                    -> BlockStat {"DefBlockStat"}
		Annotation* "implicit" Def         -> BlockStat {"ImplicitDefBlockStat"}
		Annotation* "lazy" Def             -> BlockStat {"LazyDefBlockStat"}
		Annotation* LocalModifier* TmplDef -> BlockStat {"TmplDefBlockStat"}
			
		Id (":" Type)?  -> Binding {"Binding"}
		"_" (":" Type)? -> Binding {"WildCardBinding"}
		
		"(" {Binding ","}* ")" -> Bindings {"Bindings"}

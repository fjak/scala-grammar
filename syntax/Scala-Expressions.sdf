module Scala-Expressions

imports
	Scala-Whitespace
	Scala-Literals
	Scala-Paths
	Scala-Types
	Scala-Annotations
	Scala-PatternMatching
	Scala-Modifiers
	Scala-Imports
	Scala-Templates
	
exports
	lexical syntax
		";" -> Semi
		"\n" -> Nl
		"+" -> Prefix
		"-" -> Prefix
		"~" -> Prefix
		"!" -> Prefix
		
	lexical restrictions
		Prefix -/- [\+\-\~\!]

	context-free priorities
		{
			"_"                 -> Expr {"WildcardExpr"}
			Literal             -> Expr {"LiteralExpr", prefer}
			Path                -> Expr {"PathExpr"}
			Expr ArgumentExprs  -> Expr {"AppExpr", layout("1.last.line == 2.first.line")}
			Expr BlockExpr      -> Expr {"BlockAppExpr", layout("2.first.line - 1.last.line < num(2)")}
			"(" {Expr ","}* ")" -> Expr {"TupleExpr"}
			Expr TypeArgs       -> Expr {"TypeApplication"}
		}

		> {
			"new" ClassTemplate -> Expr {"NewClassExpr", prefer}
			"new" TemplateBody  -> Expr {"NewTemplateExpr", prefer}
			BlockExpr           -> Expr
			Expr "_"            -> Expr {"EtaExpansionExpr", left, layout("1.last.line == 2.first.line")}
		}
			
		> Prefix Expr  -> Expr {"PrefixExpr", right, prefer}
		> Expr Id Expr -> Expr {"InfixExpr", left, avoid, layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
		> Expr Id      -> Expr {"PostfixExpr", layout("1.last.line == 2.first.line")}
		> Expr Id      -> Expr {"PostfixExpr", layout("1.last.line == 2.first.line")}

		> {
			Bindings "=>" Expr                                                   -> Expr {"FunExpr", prefer}
			Id "=>" Expr                                                         -> Expr {"IdFunExpr", prefer}
			"implicit" Id "=>" Expr                                              -> Expr {"ImplicitFunExpr", prefer}
			"_" "=>" Expr                                                        -> Expr {"WildcardFunExpr", prefer}
			"if" "(" Expr ")" Expr                                               -> Expr {"IfExpr"}
			"if" "(" Expr ")" Expr "else" Expr                                   -> Expr {"IfElseExpr"}
			"if" "(" Expr ")" Expr ";" "else" Expr                               -> Expr {"IfElseExpr"}
			"while" "(" Expr ")" Expr                                            -> Expr {"WhileExpr"}
			"try" "{" Block "}" ("catch" "{" CaseClauses "}")? ("finally" Expr)? -> Expr {"TryExpr"}
			"do" Expr Semi? "while" "(" Expr ")"                                 -> Expr {"DoWhileExpr"}
			"for" "(" Enumerators ")" Expr                                       -> Expr {"BraceForExpr"}
			"for" "{" Enumerators "}" Expr                                       -> Expr {"CurlyBraceForExpr"}
			"for" "(" Enumerators ")" "yield" Expr                               -> Expr {"BraceYieldForExpr"}
			"for" "{" Enumerators "}" "yield" Expr                               -> Expr {"CurlyBraceYieldForExpr"}
			"throw" Expr                                                         -> Expr {"ThrowExpr"}
			"return" Expr?                                                       -> Expr {"ReturnExpr"}
			Expr Ascription                                                      -> Expr {"AscriptionExpr", avoid}
			Expr "match" "{" CaseClauses "}"                                     -> Expr {"MatchExpr"}
			(Expr ".")? Id "=" Expr                                              -> Expr {"AssignmentExpr", non-assoc}
			Expr ArgumentExprs "=" Expr                                          -> Expr {"AccessAssignmentExpr", non-assoc}
		}

	context-free priorities
		Expr "." Id        -> Expr {"DesignatorExpr", avoid}
		> Prefix Expr      -> Expr {"PrefixExpr"}

	context-free syntax
		"(" Exprs? ")"                               -> ArgumentExprs {"ArgumentExprs"}
		"(" (Exprs ",")? Expr ":" "_" "*" ")"        -> ArgumentExprs {"SequenceArgumentExprs", prefer}

		ArgumentExprs                  -> ArgumentExprsSeq
		ArgumentExprs ArgumentExprsSeq -> ArgumentExprsSeq {"ArgumentExprsSeq", layout("1.last.line == 2.first.line")}

		{Expr ","}+ -> Exprs {"Exprs"}
		
		":" InfixType   -> Ascription {"TypeAscription"}
		":" Annotation+ -> Ascription {"AnnotationAscription"}
		":" "_" "*"     -> Ascription {"SequenceAscription"}
		
		Pattern1 "<-" Expr Guard? -> Generator {"Generator"}
		
		"if" Expr -> Guard {"Guard"}
		
		Generator                   -> Enumerators 
		Generator ";" EnumeratorSeq -> Enumerators {"SemiEnumerators"}
		Generator EnumeratorSeq     -> Enumerators {"Enumerators", layout("2.first.line > 1.last.line")}
		
		Enumerator                   -> EnumeratorSeq {"SingleEnumeratorSeq"}
		Enumerator ";" EnumeratorSeq -> EnumeratorSeq {"SemiEnumeratorSeq"}
		Enumerator EnumeratorSeq     -> EnumeratorSeq {"EnumeratorSeq", layout("2.first.line > 1.last.line")}
		
		Generator                    -> Enumerator
		Guard                        -> Enumerator
		"val" Pattern1 "=" Expr -> Enumerator {"Enumerator"}
		
		"case" Pattern Guard? "=>" Block -> CaseClause {"CaseClause"}
		
		CaseClause+ -> CaseClauses {"CaseClauses"}
		
		"{" CaseClauses "}" -> BlockExpr {"CaseBlockExpr"}
		"{" Block "}"       -> BlockExpr {"BlockExpr"}
		
		BlockStatSemi* ResultExpr -> Block {"BlockWithResult", prefer}
		BlockStatSemi*            -> Block {"BlockWithoutResult"}
		
		BlockStat EOL -> BlockStatSemi {"BlockStatSemi", enforce-newline, prefer}
		BlockStat EOB -> BlockStatSemi {"EOBBlockStatSemi", avoid}
		BlockStat ";" -> BlockStatSemi {"SemiBlockStatSemi"}
		
		%% Only treat "special" expressions as ResultExpr to avoid ambiguity with BlockStatSemi
		%% Expr1                                     -> ResultExpr
		Bindings "=>" Block                       -> ResultExpr {"BindingsResultExpr"}
		"implicit" Id ":" CompoundType "=>" Block -> ResultExpr {"ImplicitResultExpr"}
		Id ":" CompoundType "=>" Block            -> ResultExpr {"SimpleResultExpr"}
		"_" ":" CompoundType "=>" Block           -> ResultExpr {"WildcardResultExpr"}
		Id "=>" Block                             -> ResultExpr {"SpecialOneArgResultExpr"}
		
		Import                             -> BlockStat
		Expr                               -> BlockStat
		Annotation* LocalModifier* TmplDef -> BlockStat {"TmplDefBlockStat", prefer}
		Annotation* Def                    -> BlockStat {"DefBlockStat"}
		Annotation* "implicit" Def         -> BlockStat {"ImplicitDefBlockStat"}
		Annotation* "lazy" Def             -> BlockStat {"LazyDefBlockStat"}

			
		Id (":" Type)?  -> Binding {"Binding"}
		"_" (":" Type)? -> Binding {"WildCardBinding"}
		
		"(" {Binding ","}* ")" -> Bindings {"Bindings"}

		"=" Expr -> Assignment {"Assignment"}

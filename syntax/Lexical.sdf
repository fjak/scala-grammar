module Lexical

exports

  lexical syntax 
  	[A-Z] | "$" | "_" -> Upper
  	[a-z] -> Lower
  	Upper | Lower -> Letter
  	[0-9] -> Digit
  	[\33-\39] \/ [\42-45] \/ [\47] \/ [\58-\64] \/ [\92] \/ [\94] \/ [\96] \/ [\124] \/ [\126] -> OpChar
  	
  	OpChar+ -> Op
  	Lower IdRest -> VarId
  	
  	Upper IdRest
  	| VarId
  	| Op
  	-> PlainId
  	
  	PlainId
  	| "'" StringLiteral "'"
  	-> Id
  	
  	(Letter | Digit)* ("_" Op)? -> IdRest
  	
  	(DecimalNumeral | HexNumeral | OctalNumeral) ("L" | "l")? -> IntegerLiteral
  	 ("0" | NonZeroDigit) Digit* -> DecimalNumeral
    "0" "x" HexDigit HexDigit* -> HexNumeral
    "0" OctalDigit OctalDigit* -> OctalNumeral
    "0" | NonZeroDigit -> Digit
    [1-9] -> NonZeroDigit
    [0-7] -> OctalDigit
    
    %% missing in the reference
    [0-9a-fA-F] -> HexDigit
    
    Digit+ "." Digit* ExponentPart? FloatType?
    | "." Digit+ ExponentPart? FloatType?
    | Digit+ ExponentPart FloatType?
    | Digit+ ExponentPart? FloatType
    -> FloatingPointLiteral
    
    ("E" | "e") ("+" | "-")? Digit+ -> ExponentPart
    "F" | "f" | "D" | "d" -> FloatType
    "true" | "false" -> BooleanLiteral
    
    "'" PrintableChar "'"
    | "'" CharEscapeSeq "'"
    -> CharacterLiteral
    
  	"\"" StringElement* "\""
  	| "\"\"\"" MultiLineChars "\"\"\""
  	-> StringLiteral
  	
  	PrintableCharNoDoubleQuote
  	| CharEscapeSeq
  	-> StringElement
  	
  	(("\"")? ("\"")? CharNoDoubleQuote)* "\""* -> MultiLineChars
  	"'" PlainId -> SymbolLiteral
    
    %% missing in the reference
    [\33-\126] -> PrintableChar
    [\0-\127] / [\34] -> CharNoDoubleQuote
    [\33-\126] / [\34] -> PrintableCharNoDoubleQuote
    "\\b" | "\\t" | "\\n" | "\\f" | "\\r" | "\\\"" | "\\'" | "\\\\"
    | "\\" [0-1]? [0-9]? [0-9]
    | "\\" Digit? Digit? Digit
    -> CharEscapeSeq
    
    
    [\ \t\n\r] -> LAYOUT
    
    [\*]                             -> CommentChar
    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
    
    [\n\r] -> Nl
    ";"    -> Semi
    Nl+    -> Semi
    
    -> EOF
    
	"abstract"  -> Keyword
	"case"      -> Keyword
	"catch"     -> Keyword
	"class"     -> Keyword
	"def"       -> Keyword
	"do"        -> Keyword
	"else"      -> Keyword
	"extends"   -> Keyword
	"false"     -> Keyword
	"final"     -> Keyword
	"finally"   -> Keyword
	"for"       -> Keyword
	"forSome"   -> Keyword
	"if"        -> Keyword
	"implicit"  -> Keyword
	"import"    -> Keyword
	"lazy"      -> Keyword
	"match"     -> Keyword
	"new"       -> Keyword
	"null"      -> Keyword
	"object"    -> Keyword
	"override"  -> Keyword
	"package"   -> Keyword
	"private"   -> Keyword
	"protected" -> Keyword
	"return"    -> Keyword
	"sealed"    -> Keyword
	"super"     -> Keyword
	"this"      -> Keyword
	"throw"     -> Keyword
	"trait"     -> Keyword
	"try"       -> Keyword
	"true"      -> Keyword
	"type"      -> Keyword
	"val"       -> Keyword
	"var"       -> Keyword
	"while"     -> Keyword
	"with"      -> Keyword
	"yield"     -> Keyword
	"_"         -> Keyword
	":"         -> Keyword
	"="         -> Keyword
	"=>"        -> Keyword
	"<-"        -> Keyword
	"<:"        -> Keyword
	"<%"        -> Keyword
	">:"        -> Keyword
	"#"         -> Keyword
	"@"         -> Keyword
    
    Keyword -> Id {reject}
    
  lexical restrictions
  
    %% Ensure greedy matching for lexicals
  
    CommentChar   -/- [\/]
    
    %% EOF may not be followed by any char
    
    EOF           -/- ~[]

  context-free restrictions
  
    %% Ensure greedy matching for comments

    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\/]
    LAYOUT? -/- [\/].[\*]
